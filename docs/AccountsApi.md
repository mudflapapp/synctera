# Synctera::AccountsApi

All URIs are relative to *https://api-sandbox.synctera.com/v0*

| Method | HTTP request | Description |
| ------ | ------------ | ----------- |
| [**create_account**](AccountsApi.md#create_account) | **POST** /accounts | Create an account |
| [**create_account_relationship**](AccountsApi.md#create_account_relationship) | **POST** /accounts/{account_id}/relationships | Create account relationship |
| [**create_account_resource_product**](AccountsApi.md#create_account_resource_product) | **POST** /accounts/products | Create an account product |
| [**create_account_template**](AccountsApi.md#create_account_template) | **POST** /accounts/templates | Create an account template |
| [**delete_account_relationship**](AccountsApi.md#delete_account_relationship) | **DELETE** /accounts/{account_id}/relationships/{relationship_id} | Delete account relationship |
| [**delete_account_template**](AccountsApi.md#delete_account_template) | **DELETE** /accounts/templates/{template_id} | Delete account template |
| [**get_account**](AccountsApi.md#get_account) | **GET** /accounts/{account_id} | Get account |
| [**get_account_relationship**](AccountsApi.md#get_account_relationship) | **GET** /accounts/{account_id}/relationships/{relationship_id} | Get account relationship |
| [**get_account_template**](AccountsApi.md#get_account_template) | **GET** /accounts/templates/{template_id} | Get account template |
| [**list_account_relationship**](AccountsApi.md#list_account_relationship) | **GET** /accounts/{account_id}/relationships | List account relationships |
| [**list_account_resource_products**](AccountsApi.md#list_account_resource_products) | **GET** /accounts/products | List account products |
| [**list_account_templates**](AccountsApi.md#list_account_templates) | **GET** /accounts/templates | List account templates |
| [**list_accounts**](AccountsApi.md#list_accounts) | **GET** /accounts | List accounts |
| [**patch_account**](AccountsApi.md#patch_account) | **PATCH** /accounts/{account_id} | Patch account |
| [**patch_account_product**](AccountsApi.md#patch_account_product) | **PATCH** /accounts/products/{product_id} | Patch account product |
| [**update_account**](AccountsApi.md#update_account) | **PUT** /accounts/{account_id} | Update account |
| [**update_account_relationship**](AccountsApi.md#update_account_relationship) | **PUT** /accounts/{account_id}/relationships/{relationship_id} | Update account relationship |
| [**update_account_template**](AccountsApi.md#update_account_template) | **PUT** /accounts/templates/{template_id} | Update account template |


## create_account

> <AccountGenericResponse> create_account(account_creation, opts)

Create an account

Creates an account copying values from account template into the account resource.  Any fields defined as part of account creation will overwrite the ones provided from the account template.  Required fields:   - relationships 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_creation = Synctera::AccountCreation.new # AccountCreation | Account to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create an account
  result = api_instance.create_account(account_creation, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account: #{e}"
end
```

#### Using the create_account_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountGenericResponse>, Integer, Hash)> create_account_with_http_info(account_creation, opts)

```ruby
begin
  # Create an account
  data, status_code, headers = api_instance.create_account_with_http_info(account_creation, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountGenericResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_creation** | [**AccountCreation**](AccountCreation.md) | Account to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AccountGenericResponse**](AccountGenericResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_account_relationship

> <RelationshipResponse> create_account_relationship(account_id, relationship, opts)

Create account relationship

Add a customer to an account

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.
relationship = Synctera::Relationship.new({relationship_type: Synctera::AccountRelationshipType::ACCOUNT_HOLDER}) # Relationship | Account relationship object
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create account relationship
  result = api_instance.create_account_relationship(account_id, relationship, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account_relationship: #{e}"
end
```

#### Using the create_account_relationship_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<RelationshipResponse>, Integer, Hash)> create_account_relationship_with_http_info(account_id, relationship, opts)

```ruby
begin
  # Create account relationship
  data, status_code, headers = api_instance.create_account_relationship_with_http_info(account_id, relationship, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <RelationshipResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account_relationship_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_id** | **String** | Unique identifier for the account. |  |
| **relationship** | [**Relationship**](Relationship.md) | Account relationship object |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**RelationshipResponse**](RelationshipResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_account_resource_product

> <AccountProduct> create_account_resource_product(account_product, opts)

Create an account product

Create an account product. Rates cannot be nil or empty. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_product = Synctera::Fee.new({amount: 3.56, currency: 'currency_example', fee_type: 'ACH_FEE', product_type: 'FEE'}) # AccountProduct | Account product to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create an account product
  result = api_instance.create_account_resource_product(account_product, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account_resource_product: #{e}"
end
```

#### Using the create_account_resource_product_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountProduct>, Integer, Hash)> create_account_resource_product_with_http_info(account_product, opts)

```ruby
begin
  # Create an account product
  data, status_code, headers = api_instance.create_account_resource_product_with_http_info(account_product, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountProduct>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account_resource_product_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_product** | [**AccountProduct**](AccountProduct.md) | Account product to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AccountProduct**](AccountProduct.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json


## create_account_template

> <AccountTemplateResponse> create_account_template(account_template, opts)

Create an account template

Create an account template. An account template is needed to create an account in a lead mode. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_template = Synctera::AccountTemplate.new({is_enabled: false, name: 'name_example', template: Synctera::TemplateFieldsChargeSecured.new({account_type: Synctera::AccountType::CHARGE_SECURED, bank_country: 'US', currency: 'USD', minimum_payment: Synctera::MinimumPaymentTypeFull.new({type: Synctera::MinimumPaymentType::FULL})})}) # AccountTemplate | Account template to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create an account template
  result = api_instance.create_account_template(account_template, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account_template: #{e}"
end
```

#### Using the create_account_template_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountTemplateResponse>, Integer, Hash)> create_account_template_with_http_info(account_template, opts)

```ruby
begin
  # Create an account template
  data, status_code, headers = api_instance.create_account_template_with_http_info(account_template, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountTemplateResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->create_account_template_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_template** | [**AccountTemplate**](AccountTemplate.md) | Account template to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AccountTemplateResponse**](AccountTemplateResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json


## delete_account_relationship

> <DeleteResponse> delete_account_relationship(relationship_id, account_id)

Delete account relationship

Delete account relationship

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
relationship_id = '1a582c51-e4ff-4e57-9558-08cab6b963aa' # String | Relationship ID of the account associate with the account entity
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.

begin
  # Delete account relationship
  result = api_instance.delete_account_relationship(relationship_id, account_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->delete_account_relationship: #{e}"
end
```

#### Using the delete_account_relationship_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<DeleteResponse>, Integer, Hash)> delete_account_relationship_with_http_info(relationship_id, account_id)

```ruby
begin
  # Delete account relationship
  data, status_code, headers = api_instance.delete_account_relationship_with_http_info(relationship_id, account_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <DeleteResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->delete_account_relationship_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **relationship_id** | **String** | Relationship ID of the account associate with the account entity |  |
| **account_id** | **String** | Unique identifier for the account. |  |

### Return type

[**DeleteResponse**](DeleteResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## delete_account_template

> <DeleteResponse> delete_account_template(template_id)

Delete account template

Delete account template

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
template_id = 'a8943c51-e4ff-4e57-9558-08cab6b963c0' # String | Account Template ID

begin
  # Delete account template
  result = api_instance.delete_account_template(template_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->delete_account_template: #{e}"
end
```

#### Using the delete_account_template_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<DeleteResponse>, Integer, Hash)> delete_account_template_with_http_info(template_id)

```ruby
begin
  # Delete account template
  data, status_code, headers = api_instance.delete_account_template_with_http_info(template_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <DeleteResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->delete_account_template_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **template_id** | **String** | Account Template ID |  |

### Return type

[**DeleteResponse**](DeleteResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_account

> <AccountGenericResponse> get_account(account_id)

Get account

Get an account

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.

begin
  # Get account
  result = api_instance.get_account(account_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->get_account: #{e}"
end
```

#### Using the get_account_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountGenericResponse>, Integer, Hash)> get_account_with_http_info(account_id)

```ruby
begin
  # Get account
  data, status_code, headers = api_instance.get_account_with_http_info(account_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountGenericResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->get_account_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_id** | **String** | Unique identifier for the account. |  |

### Return type

[**AccountGenericResponse**](AccountGenericResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_account_relationship

> <RelationshipResponse> get_account_relationship(relationship_id, account_id)

Get account relationship

Get account relationship by ID

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
relationship_id = '1a582c51-e4ff-4e57-9558-08cab6b963aa' # String | Relationship ID of the account associate with the account entity
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.

begin
  # Get account relationship
  result = api_instance.get_account_relationship(relationship_id, account_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->get_account_relationship: #{e}"
end
```

#### Using the get_account_relationship_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<RelationshipResponse>, Integer, Hash)> get_account_relationship_with_http_info(relationship_id, account_id)

```ruby
begin
  # Get account relationship
  data, status_code, headers = api_instance.get_account_relationship_with_http_info(relationship_id, account_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <RelationshipResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->get_account_relationship_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **relationship_id** | **String** | Relationship ID of the account associate with the account entity |  |
| **account_id** | **String** | Unique identifier for the account. |  |

### Return type

[**RelationshipResponse**](RelationshipResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_account_template

> <AccountTemplateResponse> get_account_template(template_id)

Get account template

Get an account template

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
template_id = 'a8943c51-e4ff-4e57-9558-08cab6b963c0' # String | Account Template ID

begin
  # Get account template
  result = api_instance.get_account_template(template_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->get_account_template: #{e}"
end
```

#### Using the get_account_template_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountTemplateResponse>, Integer, Hash)> get_account_template_with_http_info(template_id)

```ruby
begin
  # Get account template
  data, status_code, headers = api_instance.get_account_template_with_http_info(template_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountTemplateResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->get_account_template_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **template_id** | **String** | Account Template ID |  |

### Return type

[**AccountTemplateResponse**](AccountTemplateResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json


## list_account_relationship

> <RelationshipList> list_account_relationship(account_id, opts)

List account relationships

List all customers of an account

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.
opts = {
  page_token: 'a8937a0d', # String | 
  limit: 100 # Integer | 
}

begin
  # List account relationships
  result = api_instance.list_account_relationship(account_id, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_account_relationship: #{e}"
end
```

#### Using the list_account_relationship_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<RelationshipList>, Integer, Hash)> list_account_relationship_with_http_info(account_id, opts)

```ruby
begin
  # List account relationships
  data, status_code, headers = api_instance.list_account_relationship_with_http_info(account_id, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <RelationshipList>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_account_relationship_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_id** | **String** | Unique identifier for the account. |  |
| **page_token** | **String** |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |

### Return type

[**RelationshipList**](RelationshipList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_account_resource_products

> <AccountProductList> list_account_resource_products(product_type, opts)

List account products

List account Products 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
product_type = 'FEE' # String | Type of account product
opts = {
  end_date: Date.parse('2013-10-20'), # Date | Date range filtering for type INTEREST. All rates in interest resource have to have valid_to earlier or equal to end_date.
  page_token: 'a8937a0d', # String | 
  id: 'id_example', # String | ID of account product. Multiple IDs can be provided as a comma-separated list.
  limit: 100, # Integer | 
  start_date: Date.parse('2013-10-20') # Date | Date range filtering for type INTEREST. All rates in interest resource have to have valid_from later or equal to start_date.
}

begin
  # List account products
  result = api_instance.list_account_resource_products(product_type, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_account_resource_products: #{e}"
end
```

#### Using the list_account_resource_products_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountProductList>, Integer, Hash)> list_account_resource_products_with_http_info(product_type, opts)

```ruby
begin
  # List account products
  data, status_code, headers = api_instance.list_account_resource_products_with_http_info(product_type, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountProductList>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_account_resource_products_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **product_type** | **String** | Type of account product |  |
| **end_date** | **Date** | Date range filtering for type INTEREST. All rates in interest resource have to have valid_to earlier or equal to end_date. | [optional] |
| **page_token** | **String** |  | [optional] |
| **id** | **String** | ID of account product. Multiple IDs can be provided as a comma-separated list. | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |
| **start_date** | **Date** | Date range filtering for type INTEREST. All rates in interest resource have to have valid_from later or equal to start_date. | [optional] |

### Return type

[**AccountProductList**](AccountProductList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json


## list_account_templates

> <TemplateList> list_account_templates(opts)

List account templates

List account templates 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
opts = {
  account_type: Synctera::AccountType::CHARGE_SECURED, # AccountType | The type of the account 
  page_token: 'a8937a0d', # String | 
  limit: 100 # Integer | 
}

begin
  # List account templates
  result = api_instance.list_account_templates(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_account_templates: #{e}"
end
```

#### Using the list_account_templates_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<TemplateList>, Integer, Hash)> list_account_templates_with_http_info(opts)

```ruby
begin
  # List account templates
  data, status_code, headers = api_instance.list_account_templates_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <TemplateList>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_account_templates_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_type** | [**AccountType**](.md) | The type of the account  | [optional] |
| **page_token** | **String** |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |

### Return type

[**TemplateList**](TemplateList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json


## list_accounts

> <AccountList> list_accounts(opts)

List accounts

Get paginated list of Accounts associated

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
opts = {
  nickname: 'nickname_example', # String | Nickname of the account 
  account_number: ['inner_example'], # Array<String> | Account number(s). Multiple account numbers can be provided as a comma-separated list. When only a single account number is provided, any * characters in the string are wildcards, and match any characters. 
  last_name: 'Smith', # String | 
  status: Synctera::Status::ACCOUNT_NEVER_ACTIVE, # Status | 
  first_name: 'Alice', # String | 
  overflow_account_id: ['inner_example'], # Array<String> | Overflow account ID(s). Multiple IDs can be provided as a comma-separated list. This parameter is deprecated and will be removed in a future API version. Use linked_account_id instead. 
  account_type: Synctera::AccountType::CHARGE_SECURED, # AccountType | The type of the account 
  business_id: ['inner_example'], # Array<String> | Unique identifier for the business. Multiple IDs can be provided as a comma-separated list. 
  overdraft_account_id: ['inner_example'], # Array<String> | Overdraft account ID(s). Multiple IDs can be provided as a comma-separated list. This parameter is deprecated and will be removed in a future API version. Use linked_account_id instead. 
  spend_control_ids: ['7d943c51-e4ff-4e57-9558-08cab6b963c7'], # Array<String> | Spend Control ID(s). Multiple IDs can be provided as a comma-separated list. Return only resources that use the specified Spend Controls. 
  page_token: 'a8937a0d', # String | 
  person_id: ['inner_example'], # Array<String> | Unique identifier for the person. Multiple IDs can be provided as a comma-separated list. 
  customer_type: Synctera::CustomerType::BUSINESS, # CustomerType | Customer type of the account, BUSINESS or PERSONAL 
  limit: 100, # Integer | 
  customer_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d', # String | The customer's unique identifier
  interest_product_id: 'interest_product_id_example', # String | Interest product ID that accounts associate with. Multiple IDs can be provided as a comma-separated list.
  linked_account_id: ['inner_example'], # Array<String> | Return only resources that are linked to the specified backing account in balance_floor or balance_ceiling. Multiple IDs can be provided as a comma-separated list. 
  id: ['inner_example'], # Array<String> | Account ID(s). Multiple IDs can be provided as a comma-separated list. 
  sort_by: ['account_number:asc'] # Array<String> | Specifies the sort order for the returned accounts. 
}

begin
  # List accounts
  result = api_instance.list_accounts(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_accounts: #{e}"
end
```

#### Using the list_accounts_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountList>, Integer, Hash)> list_accounts_with_http_info(opts)

```ruby
begin
  # List accounts
  data, status_code, headers = api_instance.list_accounts_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountList>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->list_accounts_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **nickname** | **String** | Nickname of the account  | [optional] |
| **account_number** | [**Array&lt;String&gt;**](String.md) | Account number(s). Multiple account numbers can be provided as a comma-separated list. When only a single account number is provided, any * characters in the string are wildcards, and match any characters.  | [optional] |
| **last_name** | **String** |  | [optional] |
| **status** | [**Status**](.md) |  | [optional] |
| **first_name** | **String** |  | [optional] |
| **overflow_account_id** | [**Array&lt;String&gt;**](String.md) | Overflow account ID(s). Multiple IDs can be provided as a comma-separated list. This parameter is deprecated and will be removed in a future API version. Use linked_account_id instead.  | [optional] |
| **account_type** | [**AccountType**](.md) | The type of the account  | [optional] |
| **business_id** | [**Array&lt;String&gt;**](String.md) | Unique identifier for the business. Multiple IDs can be provided as a comma-separated list.  | [optional] |
| **overdraft_account_id** | [**Array&lt;String&gt;**](String.md) | Overdraft account ID(s). Multiple IDs can be provided as a comma-separated list. This parameter is deprecated and will be removed in a future API version. Use linked_account_id instead.  | [optional] |
| **spend_control_ids** | [**Array&lt;String&gt;**](String.md) | Spend Control ID(s). Multiple IDs can be provided as a comma-separated list. Return only resources that use the specified Spend Controls.  | [optional] |
| **page_token** | **String** |  | [optional] |
| **person_id** | [**Array&lt;String&gt;**](String.md) | Unique identifier for the person. Multiple IDs can be provided as a comma-separated list.  | [optional] |
| **customer_type** | [**CustomerType**](.md) | Customer type of the account, BUSINESS or PERSONAL  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |
| **customer_id** | **String** | The customer&#39;s unique identifier | [optional] |
| **interest_product_id** | **String** | Interest product ID that accounts associate with. Multiple IDs can be provided as a comma-separated list. | [optional] |
| **linked_account_id** | [**Array&lt;String&gt;**](String.md) | Return only resources that are linked to the specified backing account in balance_floor or balance_ceiling. Multiple IDs can be provided as a comma-separated list.  | [optional] |
| **id** | [**Array&lt;String&gt;**](String.md) | Account ID(s). Multiple IDs can be provided as a comma-separated list.  | [optional] |
| **sort_by** | [**Array&lt;String&gt;**](String.md) | Specifies the sort order for the returned accounts.  | [optional] |

### Return type

[**AccountList**](AccountList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## patch_account

> <AccountGenericResponse> patch_account(account_id, patch_account, opts)

Patch account

Patch account.  Immutable fields:   - account_number   - account_type   - account_template_id   - customer_type  Please note:   - Other fields cannot be modified when access_status is FROZEN.   - access_status has to be patched individually without other fields. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.
patch_account = Synctera::PatchAccount.new # PatchAccount | Account fields to be patched
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Patch account
  result = api_instance.patch_account(account_id, patch_account, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->patch_account: #{e}"
end
```

#### Using the patch_account_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountGenericResponse>, Integer, Hash)> patch_account_with_http_info(account_id, patch_account, opts)

```ruby
begin
  # Patch account
  data, status_code, headers = api_instance.patch_account_with_http_info(account_id, patch_account, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountGenericResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->patch_account_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_id** | **String** | Unique identifier for the account. |  |
| **patch_account** | [**PatchAccount**](PatchAccount.md) | Account fields to be patched |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AccountGenericResponse**](AccountGenericResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## patch_account_product

> <AccountProduct> patch_account_product(product_id, patch_account_product, opts)

Patch account product

Patch account product. Rates requires at minimum 1 entry if specified. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
product_id = '92113c51-e4ff-4e57-9558-08cab6b963dd' # String | Account Product ID
patch_account_product = Synctera::Fee.new({amount: 3.56, currency: 'currency_example', fee_type: 'ACH_FEE', product_type: 'FEE'}) # PatchAccountProduct | Account product fields to be patched
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Patch account product
  result = api_instance.patch_account_product(product_id, patch_account_product, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->patch_account_product: #{e}"
end
```

#### Using the patch_account_product_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountProduct>, Integer, Hash)> patch_account_product_with_http_info(product_id, patch_account_product, opts)

```ruby
begin
  # Patch account product
  data, status_code, headers = api_instance.patch_account_product_with_http_info(product_id, patch_account_product, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountProduct>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->patch_account_product_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **product_id** | **String** | Account Product ID |  |
| **patch_account_product** | [**PatchAccountProduct**](PatchAccountProduct.md) | Account product fields to be patched |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AccountProduct**](AccountProduct.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## update_account

> <AccountGenericResponse> update_account(account_id, update_account)

Update account

> Deprecated. Please use PATCH /v0/accounts. This route only supports types CHECKING and SAVING.  Update account  Shadow mode required fields:   - account_number   - status  Lead mode required fields:   - All fields are required.  Please note:   - access_status needs to be in ACTIVE.   - PUT request cannot change access_status. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.
update_account = Synctera::UpdateAccount.new # UpdateAccount | Account to update

begin
  # Update account
  result = api_instance.update_account(account_id, update_account)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->update_account: #{e}"
end
```

#### Using the update_account_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountGenericResponse>, Integer, Hash)> update_account_with_http_info(account_id, update_account)

```ruby
begin
  # Update account
  data, status_code, headers = api_instance.update_account_with_http_info(account_id, update_account)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountGenericResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->update_account_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_id** | **String** | Unique identifier for the account. |  |
| **update_account** | [**UpdateAccount**](UpdateAccount.md) | Account to update |  |

### Return type

[**AccountGenericResponse**](AccountGenericResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## update_account_relationship

> <RelationshipResponse> update_account_relationship(relationship_id, account_id, relationship)

Update account relationship

Update account relationship. Only relationship_type can be updated. customer_id should not be modified.

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
relationship_id = '1a582c51-e4ff-4e57-9558-08cab6b963aa' # String | Relationship ID of the account associate with the account entity
account_id = '57826c51-e4ff-4e57-9558-08cab6b963c7' # String | Unique identifier for the account.
relationship = Synctera::Relationship.new({relationship_type: Synctera::AccountRelationshipType::ACCOUNT_HOLDER}) # Relationship | Account relationship to be updated

begin
  # Update account relationship
  result = api_instance.update_account_relationship(relationship_id, account_id, relationship)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->update_account_relationship: #{e}"
end
```

#### Using the update_account_relationship_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<RelationshipResponse>, Integer, Hash)> update_account_relationship_with_http_info(relationship_id, account_id, relationship)

```ruby
begin
  # Update account relationship
  data, status_code, headers = api_instance.update_account_relationship_with_http_info(relationship_id, account_id, relationship)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <RelationshipResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->update_account_relationship_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **relationship_id** | **String** | Relationship ID of the account associate with the account entity |  |
| **account_id** | **String** | Unique identifier for the account. |  |
| **relationship** | [**Relationship**](Relationship.md) | Account relationship to be updated |  |

### Return type

[**RelationshipResponse**](RelationshipResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## update_account_template

> <AccountTemplateResponse> update_account_template(template_id, account_template)

Update account template

Update account template 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::AccountsApi.new
template_id = 'a8943c51-e4ff-4e57-9558-08cab6b963c0' # String | Account Template ID
account_template = Synctera::AccountTemplate.new({is_enabled: false, name: 'name_example', template: Synctera::TemplateFieldsChargeSecured.new({account_type: Synctera::AccountType::CHARGE_SECURED, bank_country: 'US', currency: 'USD', minimum_payment: Synctera::MinimumPaymentTypeFull.new({type: Synctera::MinimumPaymentType::FULL})})}) # AccountTemplate | Account template to update

begin
  # Update account template
  result = api_instance.update_account_template(template_id, account_template)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->update_account_template: #{e}"
end
```

#### Using the update_account_template_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AccountTemplateResponse>, Integer, Hash)> update_account_template_with_http_info(template_id, account_template)

```ruby
begin
  # Update account template
  data, status_code, headers = api_instance.update_account_template_with_http_info(template_id, account_template)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AccountTemplateResponse>
rescue Synctera::ApiError => e
  puts "Error when calling AccountsApi->update_account_template_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **template_id** | **String** | Account Template ID |  |
| **account_template** | [**AccountTemplate**](AccountTemplate.md) | Account template to update |  |

### Return type

[**AccountTemplateResponse**](AccountTemplateResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json

