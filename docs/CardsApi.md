# Synctera::CardsApi

All URIs are relative to *https://api-sandbox.synctera.com/v0*

| Method | HTTP request | Description |
| ------ | ------------ | ----------- |
| [**activate_card**](CardsApi.md#activate_card) | **POST** /cards/activate | Activate a card |
| [**create_card_image**](CardsApi.md#create_card_image) | **POST** /cards/images | Create Card Image |
| [**create_gateway**](CardsApi.md#create_gateway) | **POST** /cards/gateways | Create Gateway |
| [**get_card**](CardsApi.md#get_card) | **GET** /cards/{card_id} | Get Card |
| [**get_card_barcode**](CardsApi.md#get_card_barcode) | **GET** /cards/{card_id}/barcodes | Get Card Barcode |
| [**get_card_image_data**](CardsApi.md#get_card_image_data) | **GET** /cards/images/{card_image_id}/data | Get Card Image Data |
| [**get_card_image_details**](CardsApi.md#get_card_image_details) | **GET** /cards/images/{card_image_id} | Get Card Image Details |
| [**get_card_widget_url**](CardsApi.md#get_card_widget_url) | **GET** /cards/card_widget_url | Get card widget URL |
| [**get_client_access_token**](CardsApi.md#get_client_access_token) | **POST** /cards/{card_id}/client_token | Get a client token |
| [**get_client_single_use_token**](CardsApi.md#get_client_single_use_token) | **POST** /cards/single_use_token | Get single-use token |
| [**get_gateway**](CardsApi.md#get_gateway) | **GET** /cards/gateways/{gateway_id} | Get Gateway |
| [**issue_card**](CardsApi.md#issue_card) | **POST** /cards | Issue a Card |
| [**list_card_image_details**](CardsApi.md#list_card_image_details) | **GET** /cards/images | List Card Image Details |
| [**list_card_products**](CardsApi.md#list_card_products) | **GET** /cards/products | List Card Products |
| [**list_cards**](CardsApi.md#list_cards) | **GET** /cards | List Cards |
| [**list_changes**](CardsApi.md#list_changes) | **GET** /cards/{card_id}/changes | List Card Changes |
| [**list_gateways**](CardsApi.md#list_gateways) | **GET** /cards/gateways | List Gateways |
| [**update_card**](CardsApi.md#update_card) | **PATCH** /cards/{card_id} | Update Card |
| [**update_card_image_details**](CardsApi.md#update_card_image_details) | **PATCH** /cards/images/{card_image_id} | Update Card Image Details |
| [**update_gateway**](CardsApi.md#update_gateway) | **PATCH** /cards/gateways/{gateway_id} | Update Gateway |
| [**upload_card_image_data**](CardsApi.md#upload_card_image_data) | **POST** /cards/images/{card_image_id}/data | Upload Card Image |


## activate_card

> <CardResponse> activate_card(card_activation_request, opts)

Activate a card

Activate a card 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_activation_request = Synctera::CardActivationRequest.new({activation_code: 'activation_code_example', customer_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7'}) # CardActivationRequest | Card activation code
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Activate a card
  result = api_instance.activate_card(card_activation_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->activate_card: #{e}"
end
```

#### Using the activate_card_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardResponse>, Integer, Hash)> activate_card_with_http_info(card_activation_request, opts)

```ruby
begin
  # Activate a card
  data, status_code, headers = api_instance.activate_card_with_http_info(card_activation_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->activate_card_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_activation_request** | [**CardActivationRequest**](CardActivationRequest.md) | Card activation code |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**CardResponse**](CardResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_card_image

> <CardImageDetails> create_card_image(create_card_image_request, opts)

Create Card Image

Create a card image entity. Note that this does not include the image data itself. You can upload the image data via a subsequent uploadCardImageData request using the ID created here. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
create_card_image_request = Synctera::CreateCardImageRequest.new({card_product_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', customer_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7'}) # CreateCardImageRequest | Details of the image to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create Card Image
  result = api_instance.create_card_image(create_card_image_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->create_card_image: #{e}"
end
```

#### Using the create_card_image_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardImageDetails>, Integer, Hash)> create_card_image_with_http_info(create_card_image_request, opts)

```ruby
begin
  # Create Card Image
  data, status_code, headers = api_instance.create_card_image_with_http_info(create_card_image_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardImageDetails>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->create_card_image_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **create_card_image_request** | [**CreateCardImageRequest**](CreateCardImageRequest.md) | Details of the image to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**CardImageDetails**](CardImageDetails.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_gateway

> <GatewayResponse> create_gateway(create_gateway_request, opts)

Create Gateway

Create a new Authorization Gateway Configuration 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
create_gateway_request = Synctera::CreateGatewayRequest.new({card_products: ['7d943c51-e4ff-4e57-9558-08cab6b963c7'], url: 'url_example'}) # CreateGatewayRequest | Create a new Authorization Gateway Configuration
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create Gateway
  result = api_instance.create_gateway(create_gateway_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->create_gateway: #{e}"
end
```

#### Using the create_gateway_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<GatewayResponse>, Integer, Hash)> create_gateway_with_http_info(create_gateway_request, opts)

```ruby
begin
  # Create Gateway
  data, status_code, headers = api_instance.create_gateway_with_http_info(create_gateway_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <GatewayResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->create_gateway_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **create_gateway_request** | [**CreateGatewayRequest**](CreateGatewayRequest.md) | Create a new Authorization Gateway Configuration |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**GatewayResponse**](GatewayResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## get_card

> <CardResponse> get_card(card_id)

Get Card

Get the details about a card that has been issued 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 

begin
  # Get Card
  result = api_instance.get_card(card_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card: #{e}"
end
```

#### Using the get_card_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardResponse>, Integer, Hash)> get_card_with_http_info(card_id)

```ruby
begin
  # Get Card
  data, status_code, headers = api_instance.get_card_with_http_info(card_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_id** | **String** |  |  |

### Return type

[**CardResponse**](CardResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_card_barcode

> <GetCardBarcode200Response> get_card_barcode(card_id)

Get Card Barcode

This endpoint is for testing environment only to provide access to barcode of a test card 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 

begin
  # Get Card Barcode
  result = api_instance.get_card_barcode(card_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_barcode: #{e}"
end
```

#### Using the get_card_barcode_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<GetCardBarcode200Response>, Integer, Hash)> get_card_barcode_with_http_info(card_id)

```ruby
begin
  # Get Card Barcode
  data, status_code, headers = api_instance.get_card_barcode_with_http_info(card_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <GetCardBarcode200Response>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_barcode_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_id** | **String** |  |  |

### Return type

[**GetCardBarcode200Response**](GetCardBarcode200Response.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_card_image_data

> File get_card_image_data(card_image_id)

Get Card Image Data

Get card image data

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_image_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 

begin
  # Get Card Image Data
  result = api_instance.get_card_image_data(card_image_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_image_data: #{e}"
end
```

#### Using the get_card_image_data_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(File, Integer, Hash)> get_card_image_data_with_http_info(card_image_id)

```ruby
begin
  # Get Card Image Data
  data, status_code, headers = api_instance.get_card_image_data_with_http_info(card_image_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => File
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_image_data_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_image_id** | **String** |  |  |

### Return type

**File**

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: image/jpeg, application/problem+json


## get_card_image_details

> <CardImageDetails> get_card_image_details(card_image_id)

Get Card Image Details

Get card image details

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_image_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 

begin
  # Get Card Image Details
  result = api_instance.get_card_image_details(card_image_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_image_details: #{e}"
end
```

#### Using the get_card_image_details_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardImageDetails>, Integer, Hash)> get_card_image_details_with_http_info(card_image_id)

```ruby
begin
  # Get Card Image Details
  data, status_code, headers = api_instance.get_card_image_details_with_http_info(card_image_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardImageDetails>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_image_details_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_image_id** | **String** |  |  |

### Return type

[**CardImageDetails**](CardImageDetails.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_card_widget_url

> <CardWidgetUrlResponse> get_card_widget_url(account_id, customer_id, widget_type, opts)

Get card widget URL

This endpoint returns a URL address of the specified widget for a given card 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
account_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
customer_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
widget_type = Synctera::WidgetType::ACTIVATE_CARD # WidgetType | The type of widget for which to construct the URL
opts = {
  card_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | The ID of the card (required for set PIN widget)
}

begin
  # Get card widget URL
  result = api_instance.get_card_widget_url(account_id, customer_id, widget_type, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_widget_url: #{e}"
end
```

#### Using the get_card_widget_url_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardWidgetUrlResponse>, Integer, Hash)> get_card_widget_url_with_http_info(account_id, customer_id, widget_type, opts)

```ruby
begin
  # Get card widget URL
  data, status_code, headers = api_instance.get_card_widget_url_with_http_info(account_id, customer_id, widget_type, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardWidgetUrlResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_card_widget_url_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **account_id** | **String** |  |  |
| **customer_id** | **String** |  |  |
| **widget_type** | [**WidgetType**](.md) | The type of widget for which to construct the URL |  |
| **card_id** | **String** | The ID of the card (required for set PIN widget) | [optional] |

### Return type

[**CardWidgetUrlResponse**](CardWidgetUrlResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_client_access_token

> <ClientToken> get_client_access_token(card_id, opts)

Get a client token

Create a client access token for interacting with a card.  This token will be used on the client to identify the card for flows like viewing Full PAN or setting the PIN in a PCI compliant manner. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Get a client token
  result = api_instance.get_client_access_token(card_id, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_client_access_token: #{e}"
end
```

#### Using the get_client_access_token_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ClientToken>, Integer, Hash)> get_client_access_token_with_http_info(card_id, opts)

```ruby
begin
  # Get a client token
  data, status_code, headers = api_instance.get_client_access_token_with_http_info(card_id, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ClientToken>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_client_access_token_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_id** | **String** |  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**ClientToken**](ClientToken.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_client_single_use_token

> <SingleUseTokenResponse> get_client_single_use_token(single_use_token_request, opts)

Get single-use token

This endpoint returns a single-use access token. This type of token authorizes a single request to access API endpoints and data associated with a particular user 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
single_use_token_request = Synctera::SingleUseTokenRequest.new({account_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', customer_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7'}) # SingleUseTokenRequest | User token details
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Get single-use token
  result = api_instance.get_client_single_use_token(single_use_token_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_client_single_use_token: #{e}"
end
```

#### Using the get_client_single_use_token_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<SingleUseTokenResponse>, Integer, Hash)> get_client_single_use_token_with_http_info(single_use_token_request, opts)

```ruby
begin
  # Get single-use token
  data, status_code, headers = api_instance.get_client_single_use_token_with_http_info(single_use_token_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <SingleUseTokenResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_client_single_use_token_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **single_use_token_request** | [**SingleUseTokenRequest**](SingleUseTokenRequest.md) | User token details |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**SingleUseTokenResponse**](SingleUseTokenResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## get_gateway

> <GatewayResponse> get_gateway(gateway_id)

Get Gateway

Get the details of an Authorization Gateway that has been configured 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
gateway_id = 'gateway_id_example' # String | 

begin
  # Get Gateway
  result = api_instance.get_gateway(gateway_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_gateway: #{e}"
end
```

#### Using the get_gateway_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<GatewayResponse>, Integer, Hash)> get_gateway_with_http_info(gateway_id)

```ruby
begin
  # Get Gateway
  data, status_code, headers = api_instance.get_gateway_with_http_info(gateway_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <GatewayResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->get_gateway_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **gateway_id** | **String** |  |  |

### Return type

[**GatewayResponse**](GatewayResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## issue_card

> <CardResponse> issue_card(card_issuance_request, opts)

Issue a Card

Issue or reissue a new card for a customer 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_issuance_request = Synctera::PhysicalCardIssuanceRequest.new({account_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', card_product_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', type: Synctera::CardType::DEBIT, form: 'PHYSICAL'}) # CardIssuanceRequest | Card to issue
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Issue a Card
  result = api_instance.issue_card(card_issuance_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->issue_card: #{e}"
end
```

#### Using the issue_card_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardResponse>, Integer, Hash)> issue_card_with_http_info(card_issuance_request, opts)

```ruby
begin
  # Issue a Card
  data, status_code, headers = api_instance.issue_card_with_http_info(card_issuance_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->issue_card_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_issuance_request** | [**CardIssuanceRequest**](CardIssuanceRequest.md) | Card to issue |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**CardResponse**](CardResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## list_card_image_details

> <CardImageDetailsList> list_card_image_details(customer_id)

List Card Image Details

List all card image details 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
customer_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 

begin
  # List Card Image Details
  result = api_instance.list_card_image_details(customer_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_card_image_details: #{e}"
end
```

#### Using the list_card_image_details_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardImageDetailsList>, Integer, Hash)> list_card_image_details_with_http_info(customer_id)

```ruby
begin
  # List Card Image Details
  data, status_code, headers = api_instance.list_card_image_details_with_http_info(customer_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardImageDetailsList>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_card_image_details_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **customer_id** | **String** |  |  |

### Return type

[**CardImageDetailsList**](CardImageDetailsList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_card_products

> <CardProductListResponse> list_card_products(opts)

List Card Products

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
opts = {
  form: Synctera::Form::PHYSICAL, # Form | The format of the card
  page_token: 'a8937a0d', # String | 
  limit: 100 # Integer | 
}

begin
  # List Card Products
  result = api_instance.list_card_products(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_card_products: #{e}"
end
```

#### Using the list_card_products_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardProductListResponse>, Integer, Hash)> list_card_products_with_http_info(opts)

```ruby
begin
  # List Card Products
  data, status_code, headers = api_instance.list_card_products_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardProductListResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_card_products_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **form** | [**Form**](.md) | The format of the card | [optional] |
| **page_token** | **String** |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |

### Return type

[**CardProductListResponse**](CardProductListResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_cards

> <CardListResponse> list_cards(opts)

List Cards

List of cards matching query parameters 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
opts = {
  last_four: '1234', # String | The last 4 digits of the card PAN
  postal_code: '49633', # String | The postal code of a card user
  customer_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d', # String | 
  card_brand: Synctera::CardBrand::MASTERCARD, # CardBrand | The brand of a card product
  bin_prefix: 'bin_prefix_example', # String | 
  emboss_name: 'emboss_name_example', # String | emboss name
  card_type: Synctera::CardType::DEBIT, # CardType | Indicates the type of card
  form: Synctera::Form::PHYSICAL, # Form | The format of the card
  page_token: 'a8937a0d', # String | 
  card_status: Synctera::CardStatus::ACTIVE, # CardStatus | The status of a card
  card_product_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d', # String | 
  account_id: ['7d943c51-e4ff-4e57-9558-08cab6b963c7'], # Array<String> | Account ID(s). Multiple IDs can be provided as a comma-separated list.
  limit: 100, # Integer | 
  barcode: 'barcode_example', # String | 
  expiration_date: Date.parse('Sun Jan 01 19:00:00 EST 2006'), # Date | The date representing when the card would expire at
  sort_by: ['account_id:asc'] # Array<String> | Specifies the sort order for the returned cards. 
}

begin
  # List Cards
  result = api_instance.list_cards(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_cards: #{e}"
end
```

#### Using the list_cards_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardListResponse>, Integer, Hash)> list_cards_with_http_info(opts)

```ruby
begin
  # List Cards
  data, status_code, headers = api_instance.list_cards_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardListResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_cards_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **last_four** | **String** | The last 4 digits of the card PAN | [optional] |
| **postal_code** | **String** | The postal code of a card user | [optional] |
| **customer_id** | **String** |  | [optional] |
| **card_brand** | [**CardBrand**](.md) | The brand of a card product | [optional] |
| **bin_prefix** | **String** |  | [optional] |
| **emboss_name** | **String** | emboss name | [optional] |
| **card_type** | [**CardType**](.md) | Indicates the type of card | [optional] |
| **form** | [**Form**](.md) | The format of the card | [optional] |
| **page_token** | **String** |  | [optional] |
| **card_status** | [**CardStatus**](.md) | The status of a card | [optional] |
| **card_product_id** | **String** |  | [optional] |
| **account_id** | [**Array&lt;String&gt;**](String.md) | Account ID(s). Multiple IDs can be provided as a comma-separated list. | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |
| **barcode** | **String** |  | [optional] |
| **expiration_date** | **Date** | The date representing when the card would expire at | [optional] |
| **sort_by** | [**Array&lt;String&gt;**](String.md) | Specifies the sort order for the returned cards.  | [optional] |

### Return type

[**CardListResponse**](CardListResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_changes

> <CardChangesList> list_changes(card_id)

List Card Changes

List card change history 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 

begin
  # List Card Changes
  result = api_instance.list_changes(card_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_changes: #{e}"
end
```

#### Using the list_changes_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardChangesList>, Integer, Hash)> list_changes_with_http_info(card_id)

```ruby
begin
  # List Card Changes
  data, status_code, headers = api_instance.list_changes_with_http_info(card_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardChangesList>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_changes_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_id** | **String** |  |  |

### Return type

[**CardChangesList**](CardChangesList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_gateways

> <GatewayListResponse> list_gateways(opts)

List Gateways

List of gateways matching query parameters 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
opts = {
  page_token: 'a8937a0d', # String | 
  limit: 100 # Integer | 
}

begin
  # List Gateways
  result = api_instance.list_gateways(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_gateways: #{e}"
end
```

#### Using the list_gateways_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<GatewayListResponse>, Integer, Hash)> list_gateways_with_http_info(opts)

```ruby
begin
  # List Gateways
  data, status_code, headers = api_instance.list_gateways_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <GatewayListResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->list_gateways_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **page_token** | **String** |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |

### Return type

[**GatewayListResponse**](GatewayListResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## update_card

> <CardResponse> update_card(card_id, card_edit_request, opts)

Update Card

Integrators can update the card resource to change status, update shipping (if the card hasn't been shipped) or edit metadata. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
card_edit_request = Synctera::CardEditRequest.new # CardEditRequest | Card edits
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Update Card
  result = api_instance.update_card(card_id, card_edit_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->update_card: #{e}"
end
```

#### Using the update_card_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardResponse>, Integer, Hash)> update_card_with_http_info(card_id, card_edit_request, opts)

```ruby
begin
  # Update Card
  data, status_code, headers = api_instance.update_card_with_http_info(card_id, card_edit_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->update_card_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_id** | **String** |  |  |
| **card_edit_request** | [**CardEditRequest**](CardEditRequest.md) | Card edits |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**CardResponse**](CardResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## update_card_image_details

> <CardImageDetails> update_card_image_details(card_image_id, update_card_image_request, opts)

Update Card Image Details

Update card image details. The only detail that can be updated is the card status as APPROVED or REJECTED.

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_image_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
update_card_image_request = Synctera::UpdateCardImageRequest.new({status: Synctera::CardImageStatus::APPROVED}) # UpdateCardImageRequest | Details of the image to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Update Card Image Details
  result = api_instance.update_card_image_details(card_image_id, update_card_image_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->update_card_image_details: #{e}"
end
```

#### Using the update_card_image_details_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardImageDetails>, Integer, Hash)> update_card_image_details_with_http_info(card_image_id, update_card_image_request, opts)

```ruby
begin
  # Update Card Image Details
  data, status_code, headers = api_instance.update_card_image_details_with_http_info(card_image_id, update_card_image_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardImageDetails>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->update_card_image_details_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_image_id** | **String** |  |  |
| **update_card_image_request** | [**UpdateCardImageRequest**](UpdateCardImageRequest.md) | Details of the image to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**CardImageDetails**](CardImageDetails.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## update_gateway

> <GatewayResponse> update_gateway(gateway_id, update_gateway_request, opts)

Update Gateway

Update Authorization Gateway configuration 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
gateway_id = 'gateway_id_example' # String | 
update_gateway_request = Synctera::UpdateGatewayRequest.new # UpdateGatewayRequest | Gateway edits
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Update Gateway
  result = api_instance.update_gateway(gateway_id, update_gateway_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->update_gateway: #{e}"
end
```

#### Using the update_gateway_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<GatewayResponse>, Integer, Hash)> update_gateway_with_http_info(gateway_id, update_gateway_request, opts)

```ruby
begin
  # Update Gateway
  data, status_code, headers = api_instance.update_gateway_with_http_info(gateway_id, update_gateway_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <GatewayResponse>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->update_gateway_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **gateway_id** | **String** |  |  |
| **update_gateway_request** | [**UpdateGatewayRequest**](UpdateGatewayRequest.md) | Gateway edits |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**GatewayResponse**](GatewayResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## upload_card_image_data

> <CardImageDetails> upload_card_image_data(card_image_id, body, opts)

Upload Card Image

Upload card image data

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::CardsApi.new
card_image_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
body = File.new('/path/to/some/file') # File | Binary image data
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Upload Card Image
  result = api_instance.upload_card_image_data(card_image_id, body, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->upload_card_image_data: #{e}"
end
```

#### Using the upload_card_image_data_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<CardImageDetails>, Integer, Hash)> upload_card_image_data_with_http_info(card_image_id, body, opts)

```ruby
begin
  # Upload Card Image
  data, status_code, headers = api_instance.upload_card_image_data_with_http_info(card_image_id, body, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <CardImageDetails>
rescue Synctera::ApiError => e
  puts "Error when calling CardsApi->upload_card_image_data_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_image_id** | **String** |  |  |
| **body** | **File** | Binary image data |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**CardImageDetails**](CardImageDetails.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: image/jpeg
- **Accept**: application/json, application/problem+json

