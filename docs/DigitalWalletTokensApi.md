# Synctera::DigitalWalletTokensApi

All URIs are relative to *https://api-sandbox.synctera.com/v0*

| Method | HTTP request | Description |
| ------ | ------------ | ----------- |
| [**create_digital_wallet_apple**](DigitalWalletTokensApi.md#create_digital_wallet_apple) | **POST** /cards/{card_id}/digital_wallet_tokens/applepay | Create digital wallet token provision request for Apple Pay |
| [**create_digital_wallet_google**](DigitalWalletTokensApi.md#create_digital_wallet_google) | **POST** /cards/{card_id}/digital_wallet_tokens/googlepay | Create digital wallet token provision request for Google Pay |
| [**get_digital_wallet_token**](DigitalWalletTokensApi.md#get_digital_wallet_token) | **GET** /cards/digital_wallet_tokens/{digital_wallet_token_id} | Get Digital Wallet Token |
| [**list_digital_wallet_tokens**](DigitalWalletTokensApi.md#list_digital_wallet_tokens) | **GET** /cards/digital_wallet_tokens | List Digital Wallet Tokens |
| [**update_digital_wallet_token_status**](DigitalWalletTokensApi.md#update_digital_wallet_token_status) | **PATCH** /cards/digital_wallet_tokens/{digital_wallet_token_id} | Update Digital Wallet Token&#39;s life cycle status |


## create_digital_wallet_apple

> <AppleDigitalWalletProvisionResponse> create_digital_wallet_apple(card_id, apple_digital_wallet_provision_request, opts)

Create digital wallet token provision request for Apple Pay

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::DigitalWalletTokensApi.new
card_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
apple_digital_wallet_provision_request = Synctera::AppleDigitalWalletProvisionRequest.new({certificates: ['certificates_example'], device_type: Synctera::DeviceType::MOBILE_PHONE, nonce: 'nonce_example', nonce_signature: 'nonce_signature_example', provisioning_app_version: 'provisioning_app_version_example'}) # AppleDigitalWalletProvisionRequest | Request to provision digital wallet card data to pass to Apple Pay digital wallet.  <br>Cannot be used outside of production.</br> 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create digital wallet token provision request for Apple Pay
  result = api_instance.create_digital_wallet_apple(card_id, apple_digital_wallet_provision_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->create_digital_wallet_apple: #{e}"
end
```

#### Using the create_digital_wallet_apple_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AppleDigitalWalletProvisionResponse>, Integer, Hash)> create_digital_wallet_apple_with_http_info(card_id, apple_digital_wallet_provision_request, opts)

```ruby
begin
  # Create digital wallet token provision request for Apple Pay
  data, status_code, headers = api_instance.create_digital_wallet_apple_with_http_info(card_id, apple_digital_wallet_provision_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AppleDigitalWalletProvisionResponse>
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->create_digital_wallet_apple_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_id** | **String** |  |  |
| **apple_digital_wallet_provision_request** | [**AppleDigitalWalletProvisionRequest**](AppleDigitalWalletProvisionRequest.md) | Request to provision digital wallet card data to pass to Apple Pay digital wallet.  &lt;br&gt;Cannot be used outside of production.&lt;/br&gt;  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AppleDigitalWalletProvisionResponse**](AppleDigitalWalletProvisionResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_digital_wallet_google

> <GoogleDigitalWalletProvisionResponse> create_digital_wallet_google(card_id, google_digital_wallet_provision_request, opts)

Create digital wallet token provision request for Google Pay

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::DigitalWalletTokensApi.new
card_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
google_digital_wallet_provision_request = Synctera::GoogleDigitalWalletProvisionRequest.new({device_id: 'device_id_example', device_type: Synctera::DeviceType::MOBILE_PHONE, provisioning_app_version: 'provisioning_app_version_example', wallet_account_id: 'wallet_account_id_example'}) # GoogleDigitalWalletProvisionRequest | Request to provision digital wallet card data to pass to Google Pay digital wallet. <br>Cannot be used outside of production.</br> 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create digital wallet token provision request for Google Pay
  result = api_instance.create_digital_wallet_google(card_id, google_digital_wallet_provision_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->create_digital_wallet_google: #{e}"
end
```

#### Using the create_digital_wallet_google_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<GoogleDigitalWalletProvisionResponse>, Integer, Hash)> create_digital_wallet_google_with_http_info(card_id, google_digital_wallet_provision_request, opts)

```ruby
begin
  # Create digital wallet token provision request for Google Pay
  data, status_code, headers = api_instance.create_digital_wallet_google_with_http_info(card_id, google_digital_wallet_provision_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <GoogleDigitalWalletProvisionResponse>
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->create_digital_wallet_google_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **card_id** | **String** |  |  |
| **google_digital_wallet_provision_request** | [**GoogleDigitalWalletProvisionRequest**](GoogleDigitalWalletProvisionRequest.md) | Request to provision digital wallet card data to pass to Google Pay digital wallet. &lt;br&gt;Cannot be used outside of production.&lt;/br&gt;  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**GoogleDigitalWalletProvisionResponse**](GoogleDigitalWalletProvisionResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## get_digital_wallet_token

> <DigitalWalletTokenResponse> get_digital_wallet_token(digital_wallet_token_id)

Get Digital Wallet Token

Get the details about the digital wallet token of a card <br>NB: Digital wallet tokens cannot be created outside of production</br> 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::DigitalWalletTokensApi.new
digital_wallet_token_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 

begin
  # Get Digital Wallet Token
  result = api_instance.get_digital_wallet_token(digital_wallet_token_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->get_digital_wallet_token: #{e}"
end
```

#### Using the get_digital_wallet_token_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<DigitalWalletTokenResponse>, Integer, Hash)> get_digital_wallet_token_with_http_info(digital_wallet_token_id)

```ruby
begin
  # Get Digital Wallet Token
  data, status_code, headers = api_instance.get_digital_wallet_token_with_http_info(digital_wallet_token_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <DigitalWalletTokenResponse>
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->get_digital_wallet_token_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **digital_wallet_token_id** | **String** |  |  |

### Return type

[**DigitalWalletTokenResponse**](DigitalWalletTokenResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_digital_wallet_tokens

> <TokenListResponse> list_digital_wallet_tokens(opts)

List Digital Wallet Tokens

List Digital Wallet Tokens <br>NB: Digital wallet tokens cannot be created outside of production</br> 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::DigitalWalletTokensApi.new
opts = {
  page_token: 'a8937a0d', # String | 
  limit: 100, # Integer | 
  token_state: Synctera::DigitalWalletTokenState::ACTIVE, # DigitalWalletTokenState | The status of the Digital Wallet Token
  card_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
}

begin
  # List Digital Wallet Tokens
  result = api_instance.list_digital_wallet_tokens(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->list_digital_wallet_tokens: #{e}"
end
```

#### Using the list_digital_wallet_tokens_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<TokenListResponse>, Integer, Hash)> list_digital_wallet_tokens_with_http_info(opts)

```ruby
begin
  # List Digital Wallet Tokens
  data, status_code, headers = api_instance.list_digital_wallet_tokens_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <TokenListResponse>
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->list_digital_wallet_tokens_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **page_token** | **String** |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |
| **token_state** | [**DigitalWalletTokenState**](.md) | The status of the Digital Wallet Token | [optional] |
| **card_id** | **String** |  | [optional] |

### Return type

[**TokenListResponse**](TokenListResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## update_digital_wallet_token_status

> <DigitalWalletTokenResponse> update_digital_wallet_token_status(digital_wallet_token_id, digital_wallet_token_edit_request, opts)

Update Digital Wallet Token's life cycle status

The status of a digital wallet token can be updated as, ACTIVE to SUSPENDED, SUSPENDED to ACTIVE, ACTIVE to TERMINATED or SUSPENDED to TERMINATED. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::DigitalWalletTokensApi.new
digital_wallet_token_id = '38400000-8cf0-11bd-b23e-10b96e4ef00d' # String | 
digital_wallet_token_edit_request = Synctera::DigitalWalletTokenEditRequest.new({token_status: 'ACTIVE'}) # DigitalWalletTokenEditRequest | Update Digital wallet token status
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Update Digital Wallet Token's life cycle status
  result = api_instance.update_digital_wallet_token_status(digital_wallet_token_id, digital_wallet_token_edit_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->update_digital_wallet_token_status: #{e}"
end
```

#### Using the update_digital_wallet_token_status_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<DigitalWalletTokenResponse>, Integer, Hash)> update_digital_wallet_token_status_with_http_info(digital_wallet_token_id, digital_wallet_token_edit_request, opts)

```ruby
begin
  # Update Digital Wallet Token's life cycle status
  data, status_code, headers = api_instance.update_digital_wallet_token_status_with_http_info(digital_wallet_token_id, digital_wallet_token_edit_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <DigitalWalletTokenResponse>
rescue Synctera::ApiError => e
  puts "Error when calling DigitalWalletTokensApi->update_digital_wallet_token_status_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **digital_wallet_token_id** | **String** |  |  |
| **digital_wallet_token_edit_request** | [**DigitalWalletTokenEditRequest**](DigitalWalletTokenEditRequest.md) | Update Digital wallet token status |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**DigitalWalletTokenResponse**](DigitalWalletTokenResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json

