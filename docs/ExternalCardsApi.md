# Synctera::ExternalCardsApi

All URIs are relative to *https://api-sandbox.synctera.com/v0*

| Method | HTTP request | Description |
| ------ | ------------ | ----------- |
| [**authenticate3_ds**](ExternalCardsApi.md#authenticate3_ds) | **POST** /external_cards/authenticate_3ds | Authenticate 3DS (beta) |
| [**create_external_card_from_token**](ExternalCardsApi.md#create_external_card_from_token) | **POST** /external_cards/tokens | Create External Card from token |
| [**create_external_card_transfer**](ExternalCardsApi.md#create_external_card_transfer) | **POST** /external_cards/transfers | Create External Card Transfer |
| [**create_external_card_transfer_reversal**](ExternalCardsApi.md#create_external_card_transfer_reversal) | **POST** /external_cards/transfers/{transfer_id}/reversals | Create External Card Transfer Reversal |
| [**delete_external_card**](ExternalCardsApi.md#delete_external_card) | **DELETE** /external_cards/{external_card_id} | Delete External Card |
| [**get_external_card**](ExternalCardsApi.md#get_external_card) | **GET** /external_cards/{external_card_id} | Get External Card |
| [**get_external_card_transfer**](ExternalCardsApi.md#get_external_card_transfer) | **GET** /external_cards/transfers/{transfer_id} | Get External Card Transfer |
| [**initialize3_ds**](ExternalCardsApi.md#initialize3_ds) | **POST** /external_cards/initialize_3ds | Initialize 3DS (beta) |
| [**list_external_card_transfers**](ExternalCardsApi.md#list_external_card_transfers) | **GET** /external_cards/transfers | List External Card Transfers |
| [**list_external_cards**](ExternalCardsApi.md#list_external_cards) | **GET** /external_cards | List External Cards |
| [**lookup3_ds**](ExternalCardsApi.md#lookup3_ds) | **POST** /external_cards/lookup_3ds | Lookup 3DS (beta) |
| [**update_external_card**](ExternalCardsApi.md#update_external_card) | **PATCH** /external_cards/{external_card_id} | Update External Card |


## authenticate3_ds

> <Authenticate3dsResponse> authenticate3_ds(authenticate3ds_request, opts)

Authenticate 3DS (beta)

> ðŸš§ Beta > This is a Beta endpoint. Feedback from the community is welcome. We may make breaking changes to this endpoint.  Validates the results of an External Card Transfer 3DS authentication challenge. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
authenticate3ds_request = Synctera::Authenticate3dsRequest.new({challenge_jwt: 'challenge_jwt_example', id: '7d943c51-e4ff-4e57-9558-08cab6b963c7'}) # Authenticate3dsRequest | Details of the External Card Transfer 3DS authentication challenge validation.
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Authenticate 3DS (beta)
  result = api_instance.authenticate3_ds(authenticate3ds_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->authenticate3_ds: #{e}"
end
```

#### Using the authenticate3_ds_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<Authenticate3dsResponse>, Integer, Hash)> authenticate3_ds_with_http_info(authenticate3ds_request, opts)

```ruby
begin
  # Authenticate 3DS (beta)
  data, status_code, headers = api_instance.authenticate3_ds_with_http_info(authenticate3ds_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <Authenticate3dsResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->authenticate3_ds_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **authenticate3ds_request** | [**Authenticate3dsRequest**](Authenticate3dsRequest.md) | Details of the External Card Transfer 3DS authentication challenge validation. |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**Authenticate3dsResponse**](Authenticate3dsResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_external_card_from_token

> <ExternalCardResponse> create_external_card_from_token(external_card_request, opts)

Create External Card from token

Create an External Card from token. The token and cardholder name are obtained through the iFrame. The token must be used within 5 minutes or else it will expire. If a Business ID is provided, address verification will be performed against the legal address of the business. Otherwise, the legal address of the Customer will be used. In either case, the name of the Customer will be used to match against the cardholder name.  Each unique External Card is limited to a single Customer, so once an External Card is created for a Customer, it cannot be used for any other Customers, even if the card is deleted. Given there is a limited number of test cards, to allow easier testing, this restriction is relaxed in the sandbox environment. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
external_card_request = Synctera::ExternalCardRequest.new({customer_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', name: 'Jean Valjean', token: 'token_example'}) # ExternalCardRequest | Details of the External Card to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create External Card from token
  result = api_instance.create_external_card_from_token(external_card_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->create_external_card_from_token: #{e}"
end
```

#### Using the create_external_card_from_token_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalCardResponse>, Integer, Hash)> create_external_card_from_token_with_http_info(external_card_request, opts)

```ruby
begin
  # Create External Card from token
  data, status_code, headers = api_instance.create_external_card_from_token_with_http_info(external_card_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalCardResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->create_external_card_from_token_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_card_request** | [**ExternalCardRequest**](ExternalCardRequest.md) | Details of the External Card to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**ExternalCardResponse**](ExternalCardResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_external_card_transfer

> <TransferResponse> create_external_card_transfer(transfer_request, opts)

Create External Card Transfer

Create an External Card Transfer 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
transfer_request = Synctera::TransferRequestPull.new({amount: 37, currency: 'USD', external_card_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', originating_account_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', type: Synctera::TransferTypeRequest::PULL}) # TransferRequest | Details of the External Card Transfer to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create External Card Transfer
  result = api_instance.create_external_card_transfer(transfer_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->create_external_card_transfer: #{e}"
end
```

#### Using the create_external_card_transfer_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<TransferResponse>, Integer, Hash)> create_external_card_transfer_with_http_info(transfer_request, opts)

```ruby
begin
  # Create External Card Transfer
  data, status_code, headers = api_instance.create_external_card_transfer_with_http_info(transfer_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <TransferResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->create_external_card_transfer_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **transfer_request** | [**TransferRequest**](TransferRequest.md) | Details of the External Card Transfer to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**TransferResponse**](TransferResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_external_card_transfer_reversal

> <TransferResponse> create_external_card_transfer_reversal(transfer_id, transfer_reversal_request, opts)

Create External Card Transfer Reversal

Create an External Card Transfer Reversal 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
transfer_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | The unique identifier of a transfer
transfer_reversal_request = Synctera::TransferReversalRequest.new({amount: 37, currency: 'USD'}) # TransferReversalRequest | Details of the External Card Transfer Reversal to create
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create External Card Transfer Reversal
  result = api_instance.create_external_card_transfer_reversal(transfer_id, transfer_reversal_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->create_external_card_transfer_reversal: #{e}"
end
```

#### Using the create_external_card_transfer_reversal_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<TransferResponse>, Integer, Hash)> create_external_card_transfer_reversal_with_http_info(transfer_id, transfer_reversal_request, opts)

```ruby
begin
  # Create External Card Transfer Reversal
  data, status_code, headers = api_instance.create_external_card_transfer_reversal_with_http_info(transfer_id, transfer_reversal_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <TransferResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->create_external_card_transfer_reversal_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **transfer_id** | **String** | The unique identifier of a transfer |  |
| **transfer_reversal_request** | [**TransferReversalRequest**](TransferReversalRequest.md) | Details of the External Card Transfer Reversal to create |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**TransferResponse**](TransferResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## delete_external_card

> <DeleteResponse> delete_external_card(external_card_id)

Delete External Card

Delete an External Card

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
external_card_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | The unique identifier of an external card

begin
  # Delete External Card
  result = api_instance.delete_external_card(external_card_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->delete_external_card: #{e}"
end
```

#### Using the delete_external_card_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<DeleteResponse>, Integer, Hash)> delete_external_card_with_http_info(external_card_id)

```ruby
begin
  # Delete External Card
  data, status_code, headers = api_instance.delete_external_card_with_http_info(external_card_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <DeleteResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->delete_external_card_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_card_id** | **String** | The unique identifier of an external card |  |

### Return type

[**DeleteResponse**](DeleteResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_external_card

> <ExternalCardResponse> get_external_card(external_card_id)

Get External Card

Get an External Card 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
external_card_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | The unique identifier of an external card

begin
  # Get External Card
  result = api_instance.get_external_card(external_card_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->get_external_card: #{e}"
end
```

#### Using the get_external_card_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalCardResponse>, Integer, Hash)> get_external_card_with_http_info(external_card_id)

```ruby
begin
  # Get External Card
  data, status_code, headers = api_instance.get_external_card_with_http_info(external_card_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalCardResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->get_external_card_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_card_id** | **String** | The unique identifier of an external card |  |

### Return type

[**ExternalCardResponse**](ExternalCardResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_external_card_transfer

> <TransferResponse> get_external_card_transfer(transfer_id)

Get External Card Transfer

Get an External Card Transfer 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
transfer_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | The unique identifier of a transfer

begin
  # Get External Card Transfer
  result = api_instance.get_external_card_transfer(transfer_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->get_external_card_transfer: #{e}"
end
```

#### Using the get_external_card_transfer_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<TransferResponse>, Integer, Hash)> get_external_card_transfer_with_http_info(transfer_id)

```ruby
begin
  # Get External Card Transfer
  data, status_code, headers = api_instance.get_external_card_transfer_with_http_info(transfer_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <TransferResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->get_external_card_transfer_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **transfer_id** | **String** | The unique identifier of a transfer |  |

### Return type

[**TransferResponse**](TransferResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## initialize3_ds

> <Initialize3dsResponse> initialize3_ds(initialize3ds_request, opts)

Initialize 3DS (beta)

> ðŸš§ Beta > This is a Beta endpoint. Feedback from the community is welcome. We may make breaking changes to this endpoint.  Initializes an External Card Transfer 3DS authentication. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
initialize3ds_request = Synctera::Initialize3dsRequest.new({amount: 37, currency: 'USD', external_card_id: '7d943c51-e4ff-4e57-9558-08cab6b963c7'}) # Initialize3dsRequest | Details of the External Card Transfer 3DS authentication to initialize.
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Initialize 3DS (beta)
  result = api_instance.initialize3_ds(initialize3ds_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->initialize3_ds: #{e}"
end
```

#### Using the initialize3_ds_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<Initialize3dsResponse>, Integer, Hash)> initialize3_ds_with_http_info(initialize3ds_request, opts)

```ruby
begin
  # Initialize 3DS (beta)
  data, status_code, headers = api_instance.initialize3_ds_with_http_info(initialize3ds_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <Initialize3dsResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->initialize3_ds_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **initialize3ds_request** | [**Initialize3dsRequest**](Initialize3dsRequest.md) | Details of the External Card Transfer 3DS authentication to initialize. |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**Initialize3dsResponse**](Initialize3dsResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## list_external_card_transfers

> <TransferListResponse> list_external_card_transfers(opts)

List External Card Transfers

Get a paginated list of External Card Transfers 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
opts = {
  customer_id: ['7d943c51-e4ff-4e57-9558-08cab6b963c7'], # Array<String> | 
  type: Synctera::TransferType::PULL, # TransferType | The type of an external transfer
  originating_account_id: ['7d943c51-e4ff-4e57-9558-08cab6b963c7'], # Array<String> | 
  external_card_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d', # String | 
  page_token: 'a8937a0d', # String | 
  limit: 100 # Integer | 
}

begin
  # List External Card Transfers
  result = api_instance.list_external_card_transfers(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->list_external_card_transfers: #{e}"
end
```

#### Using the list_external_card_transfers_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<TransferListResponse>, Integer, Hash)> list_external_card_transfers_with_http_info(opts)

```ruby
begin
  # List External Card Transfers
  data, status_code, headers = api_instance.list_external_card_transfers_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <TransferListResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->list_external_card_transfers_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **customer_id** | [**Array&lt;String&gt;**](String.md) |  | [optional] |
| **type** | [**TransferType**](.md) | The type of an external transfer | [optional] |
| **originating_account_id** | [**Array&lt;String&gt;**](String.md) |  | [optional] |
| **external_card_id** | **String** |  | [optional] |
| **page_token** | **String** |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |

### Return type

[**TransferListResponse**](TransferListResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_external_cards

> <ExternalCardListResponse> list_external_cards(opts)

List External Cards

Get a paginated list of External Cards 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
opts = {
  customer_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d', # String | 
  business_id: '38400000-8cf0-11bd-b23e-10b96e4ef00d', # String | 
  page_token: 'a8937a0d', # String | 
  status: Synctera::ExternalCardStatus::ACTIVE, # ExternalCardStatus | 
  limit: 100 # Integer | 
}

begin
  # List External Cards
  result = api_instance.list_external_cards(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->list_external_cards: #{e}"
end
```

#### Using the list_external_cards_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalCardListResponse>, Integer, Hash)> list_external_cards_with_http_info(opts)

```ruby
begin
  # List External Cards
  data, status_code, headers = api_instance.list_external_cards_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalCardListResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->list_external_cards_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **customer_id** | **String** |  | [optional] |
| **business_id** | **String** |  | [optional] |
| **page_token** | **String** |  | [optional] |
| **status** | [**ExternalCardStatus**](.md) |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |

### Return type

[**ExternalCardListResponse**](ExternalCardListResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## lookup3_ds

> <Lookup3dsResponse> lookup3_ds(lookup3ds_request, opts)

Lookup 3DS (beta)

> ðŸš§ Beta > This is a Beta endpoint. Feedback from the community is welcome. We may make breaking changes to this endpoint.  Using device collection data, performs a lookup for an External Card Transfer 3DS authentication. The results will indicate whether the transfer is successfully authenticated or if a 3DS challenge is required. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
lookup3ds_request = Synctera::Lookup3dsRequestBrowser.new({authentication_indicator: 'INSTALLMENT', device_channel: 'BROWSER', id: '7d943c51-e4ff-4e57-9558-08cab6b963c7', transaction_mode: 'COMPUTER_DEVICE'}) # Lookup3dsRequest | Details of the External Card Transfer 3DS authentication lookup.
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Lookup 3DS (beta)
  result = api_instance.lookup3_ds(lookup3ds_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->lookup3_ds: #{e}"
end
```

#### Using the lookup3_ds_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<Lookup3dsResponse>, Integer, Hash)> lookup3_ds_with_http_info(lookup3ds_request, opts)

```ruby
begin
  # Lookup 3DS (beta)
  data, status_code, headers = api_instance.lookup3_ds_with_http_info(lookup3ds_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <Lookup3dsResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->lookup3_ds_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **lookup3ds_request** | [**Lookup3dsRequest**](Lookup3dsRequest.md) | Details of the External Card Transfer 3DS authentication lookup. |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**Lookup3dsResponse**](Lookup3dsResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## update_external_card

> <ExternalCardResponse> update_external_card(external_card_id, external_card_update_request)

Update External Card

Update External Card data 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalCardsApi.new
external_card_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | The unique identifier of an external card
external_card_update_request = Synctera::ExternalCardUpdateRequest.new({status: Synctera::ExternalCardStatus::ACTIVE}) # ExternalCardUpdateRequest | Fields to update

begin
  # Update External Card
  result = api_instance.update_external_card(external_card_id, external_card_update_request)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->update_external_card: #{e}"
end
```

#### Using the update_external_card_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalCardResponse>, Integer, Hash)> update_external_card_with_http_info(external_card_id, external_card_update_request)

```ruby
begin
  # Update External Card
  data, status_code, headers = api_instance.update_external_card_with_http_info(external_card_id, external_card_update_request)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalCardResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalCardsApi->update_external_card_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_card_id** | **String** | The unique identifier of an external card |  |
| **external_card_update_request** | [**ExternalCardUpdateRequest**](ExternalCardUpdateRequest.md) | Fields to update |  |

### Return type

[**ExternalCardResponse**](ExternalCardResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json

