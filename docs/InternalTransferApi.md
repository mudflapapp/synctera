# Synctera::InternalTransferApi

All URIs are relative to *https://api-sandbox.synctera.com/v0*

| Method | HTTP request | Description |
| ------ | ------------ | ----------- |
| [**create_internal_transfer**](InternalTransferApi.md#create_internal_transfer) | **POST** /transactions/internal_transfer | Create an internal transfer |
| [**get_internal_transfer_by_id**](InternalTransferApi.md#get_internal_transfer_by_id) | **GET** /transactions/internal_transfer/{id} | Get an internal transfer |
| [**update_internal_transfer_by_id**](InternalTransferApi.md#update_internal_transfer_by_id) | **PATCH** /transactions/internal_transfer/{id} | Update an internal transfer |


## create_internal_transfer

> <InternalTransferResponse> create_internal_transfer(internal_transfer, opts)

Create an internal transfer

An internal transfer is an payment between two accounts within the same Fintech.  By default, the payment is posted immediately. To indicate that you want to separate the authorization from the completion of the payment, use `capture_mode` = `MANUAL`. In that case, a separate call to update the status of the transfer will be required to complete the payment.

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::InternalTransferApi.new
internal_transfer = Synctera::InternalTransfer.new({amount: 3.56, currency: 'USD', type: 'ACCOUNT_TO_ACCOUNT'}) # InternalTransfer | Internal transfer request body
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create an internal transfer
  result = api_instance.create_internal_transfer(internal_transfer, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling InternalTransferApi->create_internal_transfer: #{e}"
end
```

#### Using the create_internal_transfer_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<InternalTransferResponse>, Integer, Hash)> create_internal_transfer_with_http_info(internal_transfer, opts)

```ruby
begin
  # Create an internal transfer
  data, status_code, headers = api_instance.create_internal_transfer_with_http_info(internal_transfer, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <InternalTransferResponse>
rescue Synctera::ApiError => e
  puts "Error when calling InternalTransferApi->create_internal_transfer_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **internal_transfer** | [**InternalTransfer**](InternalTransfer.md) | Internal transfer request body |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**InternalTransferResponse**](InternalTransferResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## get_internal_transfer_by_id

> <InternalTransferResponse> get_internal_transfer_by_id(id)

Get an internal transfer

Get an internal transfer auth by ID

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::InternalTransferApi.new
id = '472341e0-ea3e-41a1-96bc-fd0185e1eac8' # String | Transaction ID

begin
  # Get an internal transfer
  result = api_instance.get_internal_transfer_by_id(id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling InternalTransferApi->get_internal_transfer_by_id: #{e}"
end
```

#### Using the get_internal_transfer_by_id_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<InternalTransferResponse>, Integer, Hash)> get_internal_transfer_by_id_with_http_info(id)

```ruby
begin
  # Get an internal transfer
  data, status_code, headers = api_instance.get_internal_transfer_by_id_with_http_info(id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <InternalTransferResponse>
rescue Synctera::ApiError => e
  puts "Error when calling InternalTransferApi->get_internal_transfer_by_id_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **id** | **String** | Transaction ID |  |

### Return type

[**InternalTransferResponse**](InternalTransferResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## update_internal_transfer_by_id

> <InternalTransferResponse> update_internal_transfer_by_id(id, internal_transfer_patch)

Update an internal transfer

Update an internal transfer.  This is only relevant when committing or cancelling an internal transfer authorization (created with `capture_mode` = `MANUAL`) that hasn't already been completed.

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::InternalTransferApi.new
id = '472341e0-ea3e-41a1-96bc-fd0185e1eac8' # String | Transaction ID
internal_transfer_patch = Synctera::InternalTransferPatch.new # InternalTransferPatch | Internal transfer request body

begin
  # Update an internal transfer
  result = api_instance.update_internal_transfer_by_id(id, internal_transfer_patch)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling InternalTransferApi->update_internal_transfer_by_id: #{e}"
end
```

#### Using the update_internal_transfer_by_id_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<InternalTransferResponse>, Integer, Hash)> update_internal_transfer_by_id_with_http_info(id, internal_transfer_patch)

```ruby
begin
  # Update an internal transfer
  data, status_code, headers = api_instance.update_internal_transfer_by_id_with_http_info(id, internal_transfer_patch)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <InternalTransferResponse>
rescue Synctera::ApiError => e
  puts "Error when calling InternalTransferApi->update_internal_transfer_by_id_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **id** | **String** | Transaction ID |  |
| **internal_transfer_patch** | [**InternalTransferPatch**](InternalTransferPatch.md) | Internal transfer request body |  |

### Return type

[**InternalTransferResponse**](InternalTransferResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json

