# Synctera::ExternalAccountsApi

All URIs are relative to *https://api-sandbox.synctera.com/v0*

| Method | HTTP request | Description |
| ------ | ------------ | ----------- |
| [**add_external_accounts**](ExternalAccountsApi.md#add_external_accounts) | **POST** /external_accounts | Add an external account |
| [**add_vendor_external_accounts**](ExternalAccountsApi.md#add_vendor_external_accounts) | **POST** /external_accounts/add_vendor_accounts | Add external accounts through a vendor, such as Plaid. |
| [**create_access_token**](ExternalAccountsApi.md#create_access_token) | **POST** /external_accounts/access_tokens | Create a permanent access token for an external account |
| [**create_verification_link_token**](ExternalAccountsApi.md#create_verification_link_token) | **POST** /external_accounts/link_tokens | Create a link token to verify an external account |
| [**delete_external_account**](ExternalAccountsApi.md#delete_external_account) | **DELETE** /external_accounts/{external_account_id} | Delete an external account |
| [**external_account_refresh_transactions**](ExternalAccountsApi.md#external_account_refresh_transactions) | **POST** /external_accounts/{external_account_id}/refresh_transactions | Sync external account transactions through a vendor, such as Plaid |
| [**get_external_account**](ExternalAccountsApi.md#get_external_account) | **GET** /external_accounts/{external_account_id} | Get an external account |
| [**get_external_account_balance**](ExternalAccountsApi.md#get_external_account_balance) | **GET** /external_accounts/{external_account_id}/balance | Get external account balances |
| [**get_external_account_transactions**](ExternalAccountsApi.md#get_external_account_transactions) | **GET** /external_accounts/{external_account_id}/transactions | List transactions of a given external account |
| [**list_external_accounts**](ExternalAccountsApi.md#list_external_accounts) | **GET** /external_accounts | List external accounts |
| [**sync_vendor_external_accounts**](ExternalAccountsApi.md#sync_vendor_external_accounts) | **POST** /external_accounts/sync_vendor_accounts | Sync external accounts through a vendor, such as Plaid. |
| [**update_external_account**](ExternalAccountsApi.md#update_external_account) | **PATCH** /external_accounts/{external_account_id} | Patch an external account |


## add_external_accounts

> <ExternalAccount> add_external_accounts(add_accounts_request, opts)

Add an external account

Add an external account for a customer. The account will be created in an unverified state. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
add_accounts_request = Synctera::AddAccountsRequest.new({account_identifiers: Synctera::AddAccountsRequestAccountIdentifiers.new, account_owner_names: ['Jane Smith'], customer_type: Synctera::ExtAccountCustomerType::BUSINESS, routing_identifiers: Synctera::AddAccountsRequestRoutingIdentifiers.new({bank_countries: ['US'], bank_name: 'Chase'}), type: 'CHECKING'}) # AddAccountsRequest | 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Add an external account
  result = api_instance.add_external_accounts(add_accounts_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->add_external_accounts: #{e}"
end
```

#### Using the add_external_accounts_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccount>, Integer, Hash)> add_external_accounts_with_http_info(add_accounts_request, opts)

```ruby
begin
  # Add an external account
  data, status_code, headers = api_instance.add_external_accounts_with_http_info(add_accounts_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccount>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->add_external_accounts_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **add_accounts_request** | [**AddAccountsRequest**](AddAccountsRequest.md) |  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**ExternalAccount**](ExternalAccount.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## add_vendor_external_accounts

> <AddVendorAccountsResponse> add_vendor_external_accounts(add_vendor_accounts_request, opts)

Add external accounts through a vendor, such as Plaid.

Add external accounts for a customer through an existing access token. The token must be valid, and the information on the accounts returned by the vendor must correspond to the customer. A success response for this route may include failures if an account could not be added, so it's important that the caller checks the response body. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
add_vendor_accounts_request = Synctera::AddVendorAccountsRequest.new({customer_type: Synctera::ExtAccountCustomerType::BUSINESS, vendor: Synctera::ExternalAccountVendorValues::FINICITY}) # AddVendorAccountsRequest | 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Add external accounts through a vendor, such as Plaid.
  result = api_instance.add_vendor_external_accounts(add_vendor_accounts_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->add_vendor_external_accounts: #{e}"
end
```

#### Using the add_vendor_external_accounts_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AddVendorAccountsResponse>, Integer, Hash)> add_vendor_external_accounts_with_http_info(add_vendor_accounts_request, opts)

```ruby
begin
  # Add external accounts through a vendor, such as Plaid.
  data, status_code, headers = api_instance.add_vendor_external_accounts_with_http_info(add_vendor_accounts_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AddVendorAccountsResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->add_vendor_external_accounts_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **add_vendor_accounts_request** | [**AddVendorAccountsRequest**](AddVendorAccountsRequest.md) |  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AddVendorAccountsResponse**](AddVendorAccountsResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_access_token

> <ExternalAccountAccessToken> create_access_token(external_account_access_token, opts)

Create a permanent access token for an external account

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
external_account_access_token = Synctera::ExternalAccountAccessToken.new({vendor_institution_id: 'vendor_institution_id_example', vendor_public_token: 'vendor_public_token_example'}) # ExternalAccountAccessToken | 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create a permanent access token for an external account
  result = api_instance.create_access_token(external_account_access_token, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->create_access_token: #{e}"
end
```

#### Using the create_access_token_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccountAccessToken>, Integer, Hash)> create_access_token_with_http_info(external_account_access_token, opts)

```ruby
begin
  # Create a permanent access token for an external account
  data, status_code, headers = api_instance.create_access_token_with_http_info(external_account_access_token, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccountAccessToken>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->create_access_token_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_account_access_token** | [**ExternalAccountAccessToken**](ExternalAccountAccessToken.md) |  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**ExternalAccountAccessToken**](ExternalAccountAccessToken.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## create_verification_link_token

> <ExternalAccountLinkToken> create_verification_link_token(external_account_link_token, opts)

Create a link token to verify an external account

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
external_account_link_token = Synctera::ExternalAccountLinkToken.new({client_name: 'client_name_example', country_codes: ['CA'], language: Synctera::ExternalAccountLanguage::DE, type: 'CREDIT'}) # ExternalAccountLinkToken | 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Create a link token to verify an external account
  result = api_instance.create_verification_link_token(external_account_link_token, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->create_verification_link_token: #{e}"
end
```

#### Using the create_verification_link_token_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccountLinkToken>, Integer, Hash)> create_verification_link_token_with_http_info(external_account_link_token, opts)

```ruby
begin
  # Create a link token to verify an external account
  data, status_code, headers = api_instance.create_verification_link_token_with_http_info(external_account_link_token, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccountLinkToken>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->create_verification_link_token_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_account_link_token** | [**ExternalAccountLinkToken**](ExternalAccountLinkToken.md) |  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**ExternalAccountLinkToken**](ExternalAccountLinkToken.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## delete_external_account

> <DeleteResponse> delete_external_account(external_account_id)

Delete an external account

Deletes an external account, given an external account ID. If no accounts left, the access token to the financial institution will be removed 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
external_account_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | External Account ID

begin
  # Delete an external account
  result = api_instance.delete_external_account(external_account_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->delete_external_account: #{e}"
end
```

#### Using the delete_external_account_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<DeleteResponse>, Integer, Hash)> delete_external_account_with_http_info(external_account_id)

```ruby
begin
  # Delete an external account
  data, status_code, headers = api_instance.delete_external_account_with_http_info(external_account_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <DeleteResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->delete_external_account_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_account_id** | **String** | External Account ID |  |

### Return type

[**DeleteResponse**](DeleteResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## external_account_refresh_transactions

> <ExternalAccountTransactionRefreshResponse> external_account_refresh_transactions(external_account_id, opts)

Sync external account transactions through a vendor, such as Plaid

Sync external accounts for a customer through an existing access token. The token must be valid. Accounts linked in the same auth session (having the same access token) will be synced together. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
external_account_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | External Account ID
opts = {
  restricted: true, # Boolean | Is External Account Restricted for Access
  force_vendor_refresh: true # Boolean | Force a vendor refresh of the external account. 
}

begin
  # Sync external account transactions through a vendor, such as Plaid
  result = api_instance.external_account_refresh_transactions(external_account_id, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->external_account_refresh_transactions: #{e}"
end
```

#### Using the external_account_refresh_transactions_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccountTransactionRefreshResponse>, Integer, Hash)> external_account_refresh_transactions_with_http_info(external_account_id, opts)

```ruby
begin
  # Sync external account transactions through a vendor, such as Plaid
  data, status_code, headers = api_instance.external_account_refresh_transactions_with_http_info(external_account_id, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccountTransactionRefreshResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->external_account_refresh_transactions_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_account_id** | **String** | External Account ID |  |
| **restricted** | **Boolean** | Is External Account Restricted for Access | [optional] |
| **force_vendor_refresh** | **Boolean** | Force a vendor refresh of the external account.  | [optional] |

### Return type

[**ExternalAccountTransactionRefreshResponse**](ExternalAccountTransactionRefreshResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_external_account

> <ExternalAccount> get_external_account(external_account_id)

Get an external account

Returns an external account, given an external account ID. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
external_account_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | External Account ID

begin
  # Get an external account
  result = api_instance.get_external_account(external_account_id)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->get_external_account: #{e}"
end
```

#### Using the get_external_account_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccount>, Integer, Hash)> get_external_account_with_http_info(external_account_id)

```ruby
begin
  # Get an external account
  data, status_code, headers = api_instance.get_external_account_with_http_info(external_account_id)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccount>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->get_external_account_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_account_id** | **String** | External Account ID |  |

### Return type

[**ExternalAccount**](ExternalAccount.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_external_account_balance

> <ExternalAccountBalance> get_external_account_balance(external_account_id, opts)

Get external account balances

Given an external account ID, return the account balances in real time.  The data returned by this endpoint is always fetched synchronously; it is not cached by Synctera. As a result, response latency is often high. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
external_account_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | External Account ID
opts = {
  max_age: 600 # Integer | Optional relative age of a balance in seconds. If the balance is older than the requested seconds it will fail. This field is optional for most financial institutions, but required for some, so you should probably send it. 
}

begin
  # Get external account balances
  result = api_instance.get_external_account_balance(external_account_id, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->get_external_account_balance: #{e}"
end
```

#### Using the get_external_account_balance_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccountBalance>, Integer, Hash)> get_external_account_balance_with_http_info(external_account_id, opts)

```ruby
begin
  # Get external account balances
  data, status_code, headers = api_instance.get_external_account_balance_with_http_info(external_account_id, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccountBalance>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->get_external_account_balance_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_account_id** | **String** | External Account ID |  |
| **max_age** | **Integer** | Optional relative age of a balance in seconds. If the balance is older than the requested seconds it will fail. This field is optional for most financial institutions, but required for some, so you should probably send it.  | [optional] |

### Return type

[**ExternalAccountBalance**](ExternalAccountBalance.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## get_external_account_transactions

> <ExternalAccountsTransactionList> get_external_account_transactions(start_date, external_account_id, end_date)

List transactions of a given external account

Returns a list of transactions on from the external account, given an external account ID. Maximum 500 transctions will be returned. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
start_date = Date.parse('2013-10-20') # Date | Date range filtering for transactions. Date is inclusive. Date must be in UTC.
external_account_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | External Account ID
end_date = Date.parse('2013-10-20') # Date | Date range filtering for transactions. Date is exclusive. Date must be in UTC.

begin
  # List transactions of a given external account
  result = api_instance.get_external_account_transactions(start_date, external_account_id, end_date)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->get_external_account_transactions: #{e}"
end
```

#### Using the get_external_account_transactions_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccountsTransactionList>, Integer, Hash)> get_external_account_transactions_with_http_info(start_date, external_account_id, end_date)

```ruby
begin
  # List transactions of a given external account
  data, status_code, headers = api_instance.get_external_account_transactions_with_http_info(start_date, external_account_id, end_date)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccountsTransactionList>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->get_external_account_transactions_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **start_date** | **Date** | Date range filtering for transactions. Date is inclusive. Date must be in UTC. |  |
| **external_account_id** | **String** | External Account ID |  |
| **end_date** | **Date** | Date range filtering for transactions. Date is exclusive. Date must be in UTC. |  |

### Return type

[**ExternalAccountsTransactionList**](ExternalAccountsTransactionList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## list_external_accounts

> <ExternalAccountsList> list_external_accounts(opts)

List external accounts

Returns a list of all external accounts assigned to customers. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
opts = {
  id: ['inner_example'], # Array<String> | External account ID(s). Multiple IDs can be provided as a comma-separated list. 
  customer_id: ['7d943c51-e4ff-4e57-9558-08cab6b963c7'], # Array<String> | A list of customer unique identifiers, with a comma separating any values.
  include_history: true, # Boolean | If true, include old (inactive) records as well.
  page_token: 'a8937a0d', # String | 
  limit: 100, # Integer | 
  business_id: ['7d943c51-e4ff-4e57-9558-08cab6b963c7'] # Array<String> | A list of business unique identifiers, with a comma separating any values.
}

begin
  # List external accounts
  result = api_instance.list_external_accounts(opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->list_external_accounts: #{e}"
end
```

#### Using the list_external_accounts_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccountsList>, Integer, Hash)> list_external_accounts_with_http_info(opts)

```ruby
begin
  # List external accounts
  data, status_code, headers = api_instance.list_external_accounts_with_http_info(opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccountsList>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->list_external_accounts_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **id** | [**Array&lt;String&gt;**](String.md) | External account ID(s). Multiple IDs can be provided as a comma-separated list.  | [optional] |
| **customer_id** | [**Array&lt;String&gt;**](String.md) | A list of customer unique identifiers, with a comma separating any values. | [optional] |
| **include_history** | **Boolean** | If true, include old (inactive) records as well. | [optional][default to false] |
| **page_token** | **String** |  | [optional] |
| **limit** | **Integer** |  | [optional][default to 100] |
| **business_id** | [**Array&lt;String&gt;**](String.md) | A list of business unique identifiers, with a comma separating any values. | [optional] |

### Return type

[**ExternalAccountsList**](ExternalAccountsList.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: Not defined
- **Accept**: application/json, application/problem+json


## sync_vendor_external_accounts

> <AddVendorAccountsResponse> sync_vendor_external_accounts(add_vendor_accounts_request, opts)

Sync external accounts through a vendor, such as Plaid.

Sync external accounts for a customer through an existing access token. The token must be valid, and the information on the accounts returned by the vendor must correspond to the customer. A success response for this route may include failures if an account could not be added and deletions if the account is removed by the end user, so it's important that the caller checks the response body. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
add_vendor_accounts_request = Synctera::AddVendorAccountsRequest.new({customer_type: Synctera::ExtAccountCustomerType::BUSINESS, vendor: Synctera::ExternalAccountVendorValues::FINICITY}) # AddVendorAccountsRequest | 
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Sync external accounts through a vendor, such as Plaid.
  result = api_instance.sync_vendor_external_accounts(add_vendor_accounts_request, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->sync_vendor_external_accounts: #{e}"
end
```

#### Using the sync_vendor_external_accounts_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<AddVendorAccountsResponse>, Integer, Hash)> sync_vendor_external_accounts_with_http_info(add_vendor_accounts_request, opts)

```ruby
begin
  # Sync external accounts through a vendor, such as Plaid.
  data, status_code, headers = api_instance.sync_vendor_external_accounts_with_http_info(add_vendor_accounts_request, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <AddVendorAccountsResponse>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->sync_vendor_external_accounts_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **add_vendor_accounts_request** | [**AddVendorAccountsRequest**](AddVendorAccountsRequest.md) |  |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**AddVendorAccountsResponse**](AddVendorAccountsResponse.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json


## update_external_account

> <ExternalAccount> update_external_account(external_account_id, patch_external_account, opts)

Patch an external account

Edits an unverified external account, given an external account ID. 

### Examples

```ruby
require 'time'
require 'synctera'
# setup authorization
Synctera.configure do |config|
  # Configure Bearer authorization (api_key): bearerAuth
  config.access_token = 'YOUR_BEARER_TOKEN'
end

api_instance = Synctera::ExternalAccountsApi.new
external_account_id = '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | External Account ID
patch_external_account = Synctera::PatchExternalAccount.new # PatchExternalAccount | External account to be updated
opts = {
  idempotency_key: '7d943c51-e4ff-4e57-9558-08cab6b963c7' # String | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
}

begin
  # Patch an external account
  result = api_instance.update_external_account(external_account_id, patch_external_account, opts)
  p result
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->update_external_account: #{e}"
end
```

#### Using the update_external_account_with_http_info variant

This returns an Array which contains the response data, status code and headers.

> <Array(<ExternalAccount>, Integer, Hash)> update_external_account_with_http_info(external_account_id, patch_external_account, opts)

```ruby
begin
  # Patch an external account
  data, status_code, headers = api_instance.update_external_account_with_http_info(external_account_id, patch_external_account, opts)
  p status_code # => 2xx
  p headers # => { ... }
  p data # => <ExternalAccount>
rescue Synctera::ApiError => e
  puts "Error when calling ExternalAccountsApi->update_external_account_with_http_info: #{e}"
end
```

### Parameters

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **external_account_id** | **String** | External Account ID |  |
| **patch_external_account** | [**PatchExternalAccount**](PatchExternalAccount.md) | External account to be updated |  |
| **idempotency_key** | **String** | An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry. | [optional] |

### Return type

[**ExternalAccount**](ExternalAccount.md)

### Authorization

[bearerAuth](../README.md#bearerAuth)

### HTTP request headers

- **Content-Type**: application/json
- **Accept**: application/json, application/problem+json

